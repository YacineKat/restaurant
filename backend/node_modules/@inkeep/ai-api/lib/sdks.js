"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientSDK = void 0;
const http_1 = require("./http");
const security_1 = require("./security");
const url_1 = require("./url");
const encodings_1 = require("./encodings");
const base64_1 = require("./base64");
class ClientSDK {
    constructor(init) {
        this.unpackHeaders = http_1.unpackHeaders;
        this.matchStatusCode = http_1.matchStatusCode;
        this.matchResponse = http_1.matchResponse;
        this.templateURLComponent = url_1.pathToFunc;
        this.resolveSecurity = security_1.resolveSecurity;
        this.resolveGlobalSecurity = security_1.resolveGlobalSecurity;
        const url = init.baseURL;
        if (url) {
            url.pathname = url.pathname.replace(/\/+$/, "") + "/";
        }
        this.hooks$ = init.hooks;
        const { baseURL, client } = this.hooks$.sdkInit({ baseURL: url, client: init.client });
        this.baseURL = baseURL;
        this.client = client;
    }
    createRequest$(context, conf, options) {
        var _a, _b, _c;
        const { method, path, query, headers: opHeaders, security } = conf;
        const base = (_a = conf.baseURL) !== null && _a !== void 0 ? _a : this.baseURL;
        if (!base) {
            throw new TypeError("No base URL provided for operation");
        }
        const reqURL = new URL(base);
        const inputURL = new URL(path, reqURL);
        if (path) {
            reqURL.pathname += inputURL.pathname.replace(/^\/+/, "");
        }
        let finalQuery = query || "";
        const secQuery = [];
        for (const [k, v] of Object.entries((security === null || security === void 0 ? void 0 : security.queryParams) || {})) {
            secQuery.push((0, encodings_1.encodeForm)(k, v, { charEncoding: "percent" }));
        }
        if (secQuery.length) {
            finalQuery += `&${secQuery.join("&")}`;
        }
        if (finalQuery) {
            const q = finalQuery.startsWith("&") ? finalQuery.slice(1) : finalQuery;
            reqURL.search = `?${q}`;
        }
        const headers = new Headers(opHeaders);
        const username = security === null || security === void 0 ? void 0 : security.basic.username;
        const password = security === null || security === void 0 ? void 0 : security.basic.password;
        if (username != null || password != null) {
            const encoded = (0, base64_1.stringToBase64)([username || "", password || ""].join(":"));
            headers.set("Authorization", `Basic ${encoded}`);
        }
        const securityHeaders = new Headers((security === null || security === void 0 ? void 0 : security.headers) || {});
        for (const [k, v] of securityHeaders) {
            headers.set(k, v);
        }
        let cookie = headers.get("cookie") || "";
        for (const [k, v] of Object.entries((security === null || security === void 0 ? void 0 : security.cookies) || {})) {
            cookie += `; ${k}=${v}`;
        }
        cookie = cookie.startsWith("; ") ? cookie.slice(2) : cookie;
        headers.set("cookie", cookie);
        const userHeaders = new Headers((_b = options === null || options === void 0 ? void 0 : options.fetchOptions) === null || _b === void 0 ? void 0 : _b.headers);
        for (const [k, v] of userHeaders) {
            headers.set(k, v);
        }
        const input = this.hooks$.beforeCreateRequest(context, {
            url: reqURL,
            options: {
                ...options === null || options === void 0 ? void 0 : options.fetchOptions,
                body: (_c = conf.body) !== null && _c !== void 0 ? _c : null,
                headers,
                method,
            },
        });
        return new Request(input.url, input.options);
    }
    async do$(req, options) {
        const { context, errorCodes } = options;
        let response = await this.client.request(await this.hooks$.beforeRequest(context, req));
        if (this.matchStatusCode(response, errorCodes)) {
            const result = await this.hooks$.afterError(context, response, null);
            if (result.error) {
                throw result.error;
            }
            response = result.response || response;
        }
        else {
            response = await this.hooks$.afterSuccess(context, response);
        }
        return response;
    }
}
exports.ClientSDK = ClientSDK;
//# sourceMappingURL=sdks.js.map